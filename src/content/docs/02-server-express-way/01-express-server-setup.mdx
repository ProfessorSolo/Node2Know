---
title: "Start the Express Engine"
description: "Initializing the app and listening for traffic."
sidebar:
  order: 1
  label: "Start the Express Engine"
  draft: false
---

import { LinkButton } from "@astrojs/starlight/components";

## Turning the Key

To get this machine on the road, we need to do three things:

1.  **Require** the package.
2.  **Initialize** the app (turn the key).
3.  **Listen** on a port (step on the gas).

### app.js

```javascript
"use strict";

/**
 * Node2Know — Basic Express Server
 *
 * Express is an opinionated layer on top of Node’s http server:
 * - you get an app object
 * - you attach routes + middleware
 * - you start listening on a port
 */

const express = require("express");

// The ignition: this creates the Express application instance.
// Think of `app` as your server control panel (routes, middleware, config).
const app = express();

// Define the port:
// - Use the environment variable if the host provides one (common in deployment)
// - Otherwise default to 3000 locally
const PORT = process.env.PORT || 3000;

// Hit the gas: start the server.
// The callback runs once, when the server is successfully listening.
app.listen(PORT, () => {
  console.log(`Created process at PID: ${process.pid}`);
  console.log(`Listening on port: ${PORT}`);
  console.log(`Try: http://localhost:${PORT}`);
});
```

> **Solo Warning:**
> Note that `app.listen` is asynchronous. The callback function runs _after_ the server successfully binds to the port. Don't try to drive before the engine starts.

:::note[Professor Solo's Side Note (CommonJS vs ESM)]
"Wait, didn't you say `import` was the future?"

Yes. And for frontend code, it is. But in the Node.js **backend** ecosystem, `require()` (CommonJS) is still the dominant standard. It requires zero configuration and works seamlessly with 100% of the npm ecosystem. To save you from debugging config files instead of writing code, we'll stick to the industry standard for now.
:::

---

## Environment Variables: The Road Conditions

You see that `process.env.PORT` line? That's us checking the road conditions.

When we deploy this server to a cloud host (the autobahn), _they_ tell us which lane (port) to drive in. We don't get to pick. If `process.env.PORT` is defined by the environment, we use it. If not (like when we're testing in the garage), we fall back to `3000`.

**process.env** is the global dashboard for your Node process. It holds all the critical stats: API keys, database URLs, and port numbers.

### Checking the Dashboard

You can check your current environment variables in the REPL:

```bash
$ node
> console.log(process.env)
```

If you see a wall of text, congratulations, your dashboard is working.

---

## Extra Bits & Bytes

<LinkButton
  href="https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs"
  icon="external"
  variant="secondary"
  target="_blank"
>
  Node.js Env Vars Guide
</LinkButton>

<div class="next-step">
  <h3>⏭ Basic Directions</h3>
  <p>Engine's running. Now we need to tell the traffic where to go.</p>
</div>
